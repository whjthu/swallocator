#include "FreeListAllocator.h"
#include "Utils.h"
#include <cstdlib>
#include <cassert>
#include <limits>
#include <algorithm>

#define _DEBUG
#ifdef _DEBUG
#include <iostream>
#endif // _DEBUG

FreeListAllocator::FreeListAllocator(const size_t totalSize, const PlacementPolicy pPolicy) : Allocator(totalSize) {
    m_pPolicy = pPolicy;
}

void FreeListAllocator::Init() {
    if (m_start_ptr != nullptr) {
        free(m_start_ptr);
        m_start_ptr = nullptr;
    }
    m_start_ptr = malloc(m_totalSize);
    this->Reset();
}

FreeListAllocator::~FreeListAllocator() {
    if (m_start_ptr != nullptr) {
        free(m_start_ptr);
        m_start_ptr = nullptr;
    }
}

void *FreeListAllocator::Allocate(const size_t size, const size_t alignment) {
    const size_t allocationHeaderSize = sizeof(FreeListAllocator::AllocationHeader);
    const size_t freeHeaderSize = sizeof(FreeListAllocator::Node);
    // assert(size >= sizeof(Node) && "Allocation size must be bigger");
    // assert(alignment >= 8 && "Alignment must be 8 at least");

    size_t padding;
    Node *previousNode, *affectedNode;
    this->Find(size, alignment, padding, previousNode, affectedNode);
    assert(affectedNode != nullptr && "No enough memory");

    size_t alignmentPadding = padding - allocationHeaderSize;
    size_t requiredSize = size + padding;
#ifdef _DEBUG
        std::cout << "A0" << "\tRQ " << requiredSize << "\tBS " << affectedNode->data.blockSize
                  << "\tPD " << padding << "\tHS " << allocationHeaderSize
                  << "\tAN@ " << (void*)affectedNode << std::endl;
#endif // _DEBUG
    if (requiredSize > affectedNode->data.blockSize) {
        return nullptr;
    }
    const size_t rest = affectedNode->data.blockSize - requiredSize;

    // if (rest > 0) {
    if (rest >= sizeof(Node)) {
        Node *newFreeNode = (Node *)((size_t)affectedNode + requiredSize);
        newFreeNode->data.blockSize = rest;
#ifdef _DEBUG
        std::cout << "A1" << "\tNF@ " << (void*)newFreeNode << "\tBS " << newFreeNode->data.blockSize
                  << std::endl;
#endif // _DEBUG
        m_freeList.insert(affectedNode, newFreeNode);
    } else {
        requiredSize += rest;
        alignmentPadding += rest;
    }
    m_freeList.remove(previousNode, affectedNode);

    const size_t headerAddr = (size_t) affectedNode + alignmentPadding;
    const size_t dataAddr = headerAddr + allocationHeaderSize;
    ((FreeListAllocator::AllocationHeader *) headerAddr)->blockSize = requiredSize;
    ((FreeListAllocator::AllocationHeader *) headerAddr)->padding = alignmentPadding;

    m_used += requiredSize;
    m_peak = std::max(m_peak, m_used);

#ifdef _DEBUG
    std::cout << "A" << "\tH@ " << (void *) headerAddr << "\tD@ " << (void *) dataAddr
              << "\tAS " << size
              << "\tS " << ((FreeListAllocator::AllocationHeader *) headerAddr)->blockSize
              << "\tAP " << alignmentPadding << "\tP " << padding
              << "\tM " << m_used << "\tR " << rest 
              << std::endl;
#endif // _DEBUG

    return (void *) dataAddr;
}

void FreeListAllocator::Find(const size_t size, const size_t alignment, size_t &padding, Node *&previousNode, Node *&foundNode) {
    switch (m_pPolicy) {
        case FIND_FIRST: {
            FindFirst(size, alignment, padding, previousNode, foundNode);
            break;
        }
        case FIND_BEST: {
            FindBest(size, alignment, padding, previousNode, foundNode);
            break;
        }
    }
}

void FreeListAllocator::FindFirst(const size_t size, const size_t alignment, size_t &padding, Node *&previousNode, Node *&foundNode) {
    Node *it = m_freeList.head,
         *itPrev = nullptr;
    while (it != nullptr) {
        padding = Utils::CalculatePaddingWithHeader((size_t)it, alignment, sizeof(FreeListAllocator::AllocationHeader));
        const size_t requiredSpace = size + padding;
        if (it->data.blockSize >= requiredSpace) {
            break;
        }
        itPrev = it;
        it = it->next;
    }
    previousNode = itPrev;
    foundNode = it;
}

void FreeListAllocator::FindBest(const size_t size, const size_t alignment, size_t &padding, Node *&previousNode, Node *&foundNode) {
    size_t smallestDiff = std::numeric_limits<size_t>::max();
    Node *bestBlock = nullptr,
         *bestPrev = nullptr;
    Node *it = m_freeList.head,
         *itPrev = nullptr;
    while (it != nullptr) {
        padding = Utils::CalculatePaddingWithHeader((size_t)it, alignment, sizeof(FreeListAllocator::AllocationHeader));
        const size_t requiredSpace = size + padding;
        size_t diff = it->data.blockSize - requiredSpace;
        if (it->data.blockSize >= requiredSpace && (diff < smallestDiff)) {
            bestBlock = it;
            bestPrev = itPrev;
            smallestDiff = diff;
        }
        itPrev = it;
        it = it->next;
    }
    previousNode = bestPrev;
    foundNode = bestBlock;
}

void FreeListAllocator::Free(void *ptr) {
    const size_t currentAddr = (size_t)ptr;
    const size_t headerAddr = currentAddr - sizeof(FreeListAllocator::AllocationHeader);
    const FreeListAllocator::AllocationHeader *allocationHeader{
        (FreeListAllocator::AllocationHeader *) headerAddr
    };
    Node *freeNode = (Node *)(headerAddr);
    freeNode->data.blockSize = allocationHeader->blockSize + allocationHeader->padding;
    freeNode->next = nullptr;

    Node *it = m_freeList.head,
         *itPrev = nullptr;
    while (it != nullptr) {
        if (ptr < it) {
            m_freeList.insert(itPrev, freeNode);
            break;
        }
        itPrev = it;
        it = it->next;
    }
    m_used -= freeNode->data.blockSize;

    Coalescence(itPrev, freeNode);

#ifdef _DEBUG
    std::cout << "F" << "\tptr@ " << ptr << "\tH@ " << (void *)freeNode 
              << "\tS " << freeNode->data.blockSize << "\tM " << m_used << std::endl;
#endif // _DEBUG
}

void FreeListAllocator::Coalescence(Node *previousNode, Node *freeNode) {
    if (freeNode->next != nullptr && (size_t)freeNode + freeNode->data.blockSize == (size_t) freeNode->next) {
        freeNode->data.blockSize += freeNode->next->data.blockSize;
        m_freeList.remove(freeNode, freeNode->next);
#ifdef _DEBUG
        std::cout << "\tMerging(n) " << (void *)freeNode << " & " << (void*)freeNode->next
                  << "\tS " << freeNode->data.blockSize << std::endl;
#endif // _DEBUG
    }

    if (previousNode != nullptr && (size_t)previousNode + previousNode->data.blockSize == (size_t)freeNode) {
        previousNode->data.blockSize += freeNode->data.blockSize;
        m_freeList.remove(previousNode, freeNode);
#ifdef _DEBUG
        std::cout << "\tMerging(p) " << (void *)previousNode << " & " << (void*)freeNode
                  << "\tS " << previousNode->data.blockSize << std::endl;
#endif // _DEBUG
    }
}

void FreeListAllocator::Reset() {
    m_used = 0;
    m_peak = 0;
    Node *firstNode = (Node *) m_start_ptr;
    firstNode->data.blockSize = m_totalSize;
    firstNode->next = nullptr;
    m_freeList.head = nullptr;
    m_freeList.insert(nullptr, firstNode);
}
